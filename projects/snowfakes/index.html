<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Snowflake Modeling | George Geng </title> <meta name="author" content="George Geng"> <meta name="description" content="3D physically-based snowflake simulation at the mesoscopic scale, implemented in Houdini using VEX."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?98ab68992a4209ac66024f789453914e"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://jorjboi.github.io/projects/snowfakes/"> <script src="/assets/js/theme.js?55d5d4529bf41e3d82d02583f9ba3ba0"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">George</span> Geng </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/art/">art </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Snowflake Modeling</h1> <p class="post-description">3D physically-based snowflake simulation at the mesoscopic scale, implemented in Houdini using VEX.</p> </header> <article> <script type="text/javascript" async="" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script> <p><strong>Under construction!</strong></p> <ul> <li><a href="#overview">Overview</a></li> <li><a href="#algorithm">Algorthim</a></li> <li><a href="#houdini-implementation">Houdini Implementation</a></li> <li><a href="#simulation-results">Simulation Results</a></li> </ul> <h2 id="overview">Overview</h2> <p>In Houdini, I implemented a physically-based model to simulate the formuation of snowflakes, following the paper <a href="https://www.math.ucdavis.edu/~gravner/papers/h3l.pdf" rel="external nofollow noopener" target="_blank">“Modeling Snow Crystal Growth III: Three-Dimensional Snowfakes”</a> by Janko Gravner and David Griffeath. The model works on a mesoscopic scale, or approximately the micron level. This works well for capturing the overall growth patterns and behavior of ice crystals (without getting bogged down with tracking every water molecule).</p> <p>They focus on three key factors for snowflake growth: water vapor diffusion, anisotropic attachment of water molecules, and a semi-liquid boudnary layer on the surface of the ice crystal. By adjusting parameters related to these factors, this model can produce a wide variety of realistic snowflake features including branched dendrites and ridged plates.</p> <h2 id="algorithm">Algorithm</h2> <p>Our model assumes the basic building cell of an ice crystal is a hexagonal prism, with a height of <code class="language-plaintext highlighter-rouge">1</code> and a hexagonal base length of <code class="language-plaintext highlighter-rouge">1/√3</code>. At each site that an ice crystal can attach to \(x\) and time step \(t\), we keep track of two quantities: the boundary mass \(b_t(x)\) and diffusion mass \(d_t(x)\).</p> <p>Diffusive mass represents water vapor in the air, and boundary mass reprsents the thin semi-liquid layer at the snowflake’s surface that vapor can condense into before freezing into solid ice. Together, they determine whether a cell will attach to the snow crystal (freezing).</p> <div class="row justify-content-center"> <div class="col-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/snowfakes/cells.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Each number represents the number of horizontal and vertial neighbors of each cell, respectively." loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>The algorithm is as follows:</p> <ol> <li> <strong>Diffusion Calculation</strong> Calculate the horizontal diffusion by averaging the vapor diffusion mass among each cell’s 6 horizontal neighbors and the center:</li> </ol> \[d'_t(x) = \frac{1}{7} \sum_{y \in N^T_x} d^\circ_t(y)\] <p>Calculate the vertical diffusion, give a slight anisotropic weight to vertical neighbors:</p> \[d''_t(x) = \frac{8}{14} d'_t(x) + \frac{3}{14} \sum_{\substack{y \in N^Z_x \\ y \ne x}} d'_t(y)\] <p>The final diffusion step accounts for drift in the vertical direction, which happens if a snowflake is falling downwards:</p> \[d'''_t(x) = (1 - \varphi (1 - a_t(x - e_3))) \cdot d''_t(x) + \varphi (1 - a_t(x + e_3)) \cdot d''_t(x + e_3)\] <p>I use \(\varphi = 0\) for my simulations for simplicty and to ensure symmetrical results.</p> <p>2.<strong>Freezing</strong> Counting the horizontal and vertical neighbors:</p> <p>\(n^T_t(x) = \min \left( 3, \#\{ y \in N^T_x \mid a_t(y) = 1 \} \right)\) \(n^Z_t(x) = \min \left( 1, \#\{ y \in N^Z_x \mid a_t(y) = 1 \} \right)\)</p> <p>We use those to calculate the boundary mass and diffusion mass:</p> <p>\(b'_t(x) = b^\circ_t(x) + (1 - \kappa(n^T_t(x), n^Z_t(x))) \cdot d^\circ_t(x)\) \(d'_t(x) = \kappa(n^T_t(x), n^Z_t(x)) \cdot d^\circ_t(x)\)</p> <p>If the boundary mass is greater than that of its neighbors, it freezes and we can attach the cell to the ice crystal:</p> <p>\(\text{If } b^\circ_t(x) \geq \beta(n^T_t(x), n^Z_t(x))\), then cell \(x\) attaches.</p> <ol> <li> <strong>Metling</strong> When melting, part of the boundary mass becomes diffusive mass.</li> </ol> <p>\(b'_t(x) = (1 - \mu(n^T_t(x), n^Z_t(x))) \cdot b^\circ_t(x)\) \(d'_t(x) = d^\circ_t(x) + \mu(n^T_t(x), n^Z_t(x)) \cdot b^\circ_t(x)\)</p> <h2 id="numerical-integration">Numerical Integration</h2> <p>The total force acting on a mass at any instant can be found by first applying any external forces and then the forces from the spring constraints. I do this by looping over all the springs and calculating the force a spring exerts on the masses at either end using Hooke’s Law:</p> \[F_s = k_s * (\| p_a - p_b \| - l)\] <p>where \(k_s\) is the spring constant, \(p_a\) and \(p_b\) are the positions of the two end masses <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> respectively, and \(l\) is the spring’s rest length. For flexion constraints, I also scale the force by 0.2 to keep them weaker than structural or shearing constraints.</p> <p>Using the net force on each mass and numerical integration, I can find the change in each mass’s position at every time step \(dt\). Here, I use <strong>Verlet Integration</strong>. Given a particle position \(x_t\), its current velocity \(v_t\), and its acceleration \(a_t\), we calculate the next position \(x_{t + dt}\) as:</p> \[x_{t + dt} = x_t + v_tdt + a_tdt^2\] <p>We find \(a_t\) by diving the net force by the mass and can approximate \(v_tdt\) as \(x_t – x_{t - dt}\):</p> \[x_{t + dt} = x_t + (x_t – x_{t - dt}) + a_tdt^2\] <p>Finally, we introduce a damping term \(d\) to simulate energy loss over time from friction.</p> \[x_{t + dt} = x_t + (1 - d)(x_t – x_{t - dt}) + a_tdt^2\] <p>Additionally, the positions were constrained so that the spring was never elongated by more than 10%. If it exceeds 10%, I adjust the positions of the masses to satisfy the constraint. The adjustment is shared equally between two masses unless one of them is pinned, in which case the entire adjustment goes to the unpinned mass.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/numerical_integration.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Cloth sim" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Results of numerical integration </div> <h2 id="collision-handling">Collision Handling</h2> <p>We can simulate collisions with external objects such as a sphere or plane. In either case, if I detect that the location of the mass passes through the surface of the geometry, I “bump” it back up to the surface of the object.</p> <p>Specifically, for a sphere we find a correction vector that goes from the sphere’s origin to the position of the point mass. For a plane, the correction vector goes from the mass’s last position to a point where the mass should have intersected from the plane if it had traveled from its current position in a straight line to the surface of the plane.</p> <p>We apply a \((1 - f)\) scaling factor to the correction vector to account for loss of energy from friction.</p> \[p_t = (1 - f) * correction\text{_}vector + p_{t – dt}\] <p>Here are the results of running the cloth collision test with a sphere. As we increase \(k_s\), the stretchiness factor of the cloth, we see that it maintains more of its shape and becomes more rigid.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/sphere_collide.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Sphere collission" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Here is the cloth lying on a plane:</p> <h2 id="self-collisions">Self-Collisions</h2> <p>To prevent the cloth from folding over and intersecting with itself, we also need to handle self-collisions. The naive \(O(n^2)\) way of doing this would be to check if every mass is about to collide with every other mass in the grid at every time step, but this is too inefficient for real-time simulations.</p> <p>Instead, I implement spatial hashing. I subdivide the entire space into the scene into equally sized 3D boxes, map each box to a unique float, and then build a hash table from each float to a list of point masses located in the box. Then, at every time step, I only need to build the hash table and iterate through the point masses. For each point mass, I use the hash table to find a list of neighboring point masses in the same 3D volume and check for collisions between each point mass and its neighbors.</p> <div class="row justify-content-center"> <div class="col-6 mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/spatial_hash.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Spatial hashing" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>To map a 3D volume to a float, I take the coordinates of the box \((x, y, z)\) and return \(p^2x + py + z\), where \(p\) is a sufficiently large prime number. Because \(p\) is prime, \(p^2\), \(p\), and \(1\) are unlikely to have any linear combinations that produce the same value. A large enough prime creates a larger separation between \(p^2\), \(p\), and \(1\), which reduces the risk of collisions for large ranges of \((x, y, z)\).</p> <p>To see if two point masses are about to collide, I check if they are <code class="language-plaintext highlighter-rouge">2 * cloth_thicknesses</code> apart and apply a correction vector to ensure they are. The final correction vector applied to each point mass is the average of all correction vectors from its neighboring point masses, scaled down by the number of simulation steps to avoid too many sudden position corrections.</p> <p>Below are the results of the cloth falling onto itself:</p> <p>Note that as we increase the spring constant \(k_s\), the cloth folds upon itself fewer times because it simulates a stiffer fabric.</p> <h2 id="glsl-shaders">GLSL Shaders</h2> <h4 id="diffuse-and-blinn-phong-shading">Diffuse and Blinn-Phong Shading</h4> <p>I first implement diffuse and Blinn-Phong shading using a default vertex shader and different fragment shaders. The default GLSL vertex shader takes in per-vertex model-space attributes <code class="language-plaintext highlighter-rouge">in_position</code> and <code class="language-plaintext highlighter-rouge">in_normal</code> and use the model-to-world space and world space-to-screen space matrices to output <code class="language-plaintext highlighter-rouge">v_position</code> and <code class="language-plaintext highlighter-rouge">v_normal</code> for the fragment shader.</p> \[\mathbf{L} = \mathbf{k}_d\ (\mathbf{I} / r^2)\ \max(0, \mathbf{n} \cdot \mathbf{l})\] <p>The light intensity \(I\) and light position are provided as uniforms to the fragment shader, and we can find \(l\) (and \(r\)) by finding the vector from the light position to <code class="language-plaintext highlighter-rouge">v_position</code>. We set the alpha of the output color to 1 for diffuse shading.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/diffuse_shading.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Diffuse Shading" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Diffuse Shading </div> <p>Blinn-Phong shading is just like diffuse shading but with additional ambient light and specular light terms:</p> \[\mathbf{L} = \mathbf{k}_a\ \mathbf{I}_a\ + \mathbf{k}_d\ (\mathbf{I} / r^2)\ \max(0, \mathbf{n} \cdot \mathbf{l})\ + \mathbf{k}_s\ (\mathbf{I} / r^2)\ \max(0, \mathbf{n} \cdot \mathbf{h})^p\] <p>The Blinn-Phong fragment shader has the light position and camera position as uniforms, so we can find the incoming and outgoing light directions <code class="language-plaintext highlighter-rouge">w_i</code> and <code class="language-plaintext highlighter-rouge">w_o</code>. The vector \(h\) is the bisector between <code class="language-plaintext highlighter-rouge">w_i</code> and <code class="language-plaintext highlighter-rouge">w_o</code>.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/phong_shading.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Blinn-Phong Shading" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Blinn-Phong Shading </div> <h4 id="texture-mapping">Texture Mapping</h4> <p>The default vertex shader also provides the fragment shader with a UV coordinate to index into the texture uniform with the built-in GLSL function <code class="language-plaintext highlighter-rouge">texture(sampler2D tex, vec2 uv)</code>. Now, we can apply pre-loaded textures to the cloth as well:</p> <h4 id="displacement-and-bump-mapping">Displacement and Bump Mapping</h4> <p>We can also encode a height map in a texture to simulate changes in the surface of an object. With bump mapping, we can give the illusion of surface irregularities in height (bumps) by adjusting the normal vectors of an object.</p> <p>Using a texture map as a height map, I find the local space normals by looking at how the height \(h(u,v)\) changes as we make small changes in \(u\) or \(v\). We can get \(h(u,v)\) from a texture in different ways, such as by taking the <code class="language-plaintext highlighter-rouge">r</code> channel or the norm of the rgb-vector.</p> \[dU = (h(u + 1 / w, v) - h(u, v)) * k_h * k_n\] \[dV = (h(u, v + 1 / h) - h(u, v)) * k_h * k_n\] <p>To turn the local normal back into the model space normal, we can multiply by the tangent-bitangent-normal (TBN) matrix. The tangent vector can be pre-computed from the mesh geometry and loaded into the vertex shader, and passed into the fragment shader from there.</p> <p>In displacement mapping, we <i>also</i> modify the positions \(p\) of the vertices in the vertex shader in the direction of the original model space vertex normal \(n\), scaled by a factor \(k_h\).</p> \[\mathbf{p}' = \mathbf{p} + \mathbf{n} * h(u, v) * k_h\] <p>Now, we also observe a change in the geometry of the cloth:</p> <h4 id="environment-reflection-mapping">Environment Reflection Mapping</h4> <p>Using a pre-computed <a href="https://learnopengl.com/Advanced-OpenGL/Cubemaps" rel="external nofollow noopener" target="_blank">cubemap</a>, we can sample from an environment texture using a 3D direction vector. To get envrionmental reflections on our cloth, we can compute the incoming light direction <code class="language-plaintext highlighter-rouge">w_i</code> by reflecting the outgoing eye-ray over the surface normal, and use that to sample a cubemap uniform with <code class="language-plaintext highlighter-rouge">texture(samplerCube tex, vec3 dir)</code>. Below shows the result of the cloth with this mirror-like texture:</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" sizes="95vw"></source> <img src="/assets/img/clothsim/env_map.gif" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Environment Mapping" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>